# InnoDB에서 레코드의 물리적 구조 
[원문 보기](https://blog.jcole.us/2013/01/10/the-physical-structure-of-records-in-innodb/)

---

"On learning InnoDB: A journey to the core" 글에서  
InnoDB 내부 구조를 시각화하기 위한 `innodb_diagrams` 프로젝트를 소개한 바 있으며,  
이번 글에서도 그 프로젝트에서 제작한 도표를 활용하고 있습니다.

이후 "A quick introduction to innodb_ruby"에서는  
`innodb_space` 커맨드라인 도구의 설치 방법과 간단한 데모를 소개했습니다.

InnoDB의 INDEX 페이지에 대한 **물리적 구조**는  
"The physical structure of InnoDB index pages"에서,  
**논리적 구조**는 "B+Tree index structures in InnoDB"에서 설명된 바 있습니다.  
이번 글에서는 그 페이지들에서 사용되는 **레코드 자체의 물리적 구조**를 자세히 살펴보겠습니다.

참고로 이 글에서는 **Barracuda 포맷에서 사용되는 COMPACT 행 포맷**만을 대상으로 합니다.


## 레코드 오프셋 (Record Offsets)

이전 글들에서는 레코드를 참조해야 하는 여러 구조에서  
레코드 오프셋이라는 개념을 소개한 바 있습니다.  
레코드 오프셋은 가변 길이로 구성된 레코드 데이터의 시작 위치를 가리키며,  
그 앞에는 역시 가변 길이의 레코드 헤더가 존재합니다.

이번 글과 도표에서는 `N`이라는 위치를 **레코드의 시작 지점**이라 정의하고,  
레코드 데이터는 N부터 시작하여 `N+1`, `N+2`처럼 양의 방향으로 확장되며,  
레코드 헤더는 `N-1`, `N-2`와 같이 음의 방향으로 앞부분에 배치된다고 가정합니다.

InnoDB에서는 이 레코드 시작 위치인 `N`을 흔히 “origin”(기점)이라고 부릅니다.

## 레코드 헤더 (The Record Header)

이전 글들에서 레코드 헤더는 여러 차례 언급되었지만,  
전체 구조에 대해 구체적으로 설명하지는 않았습니다.  
앞서 언급한 것처럼, 레코드 헤더는 레코드 앞부분에 위치하며 다음과 같은 구조를 가집니다:

![](../reference/innodb_diagrams/images/InnoDB_Structures/Record%20Format%20-%20Header.png)

레코드 헤더에는 다음과 같은 필드들이 포함되어 있으며,  
레코드 시작점(N)을 기준으로 뒤쪽(음수 방향)부터 순서대로 배치됩니다:

- **Next Record Offset**:  
  현재 레코드로부터 다음 레코드의 시작 위치까지의 상대 오프셋입니다.  
  같은 페이지 내에서 키 순서에 따라 오름차순으로 정렬된 다음 레코드를 가리킵니다.

- **Record Type**:  
  레코드의 종류를 나타내며, 현재는 다음 네 가지 타입이 존재합니다:  
  일반 레코드(0), 노드 포인터(1), infimum(2), supremum(3)

- **Order**:  
  해당 레코드가 힙(heap)에 삽입된 순서를 나타냅니다.  
  infimum과 supremum 같은 힙 레코드는 0번부터 순서를 부여받으며,  
  infimum은 항상 0, supremum은 항상 1입니다.  
  사용자가 삽입한 레코드는 2번부터 시작됩니다.

- **Number of Records Owned**:  
  현재 레코드가 페이지 디렉토리 상에서 **논리적으로 소유**하고 있는 레코드 수입니다.  
  이 필드에 대한 상세 내용은 페이지 디렉토리 설명 글에서 다룰 예정입니다.

- **Info Flags**:  
  레코드에 대한 부가 정보를 담고 있는 4비트 플래그 비트맵입니다.  
  현재 정의된 플래그는 다음 두 가지입니다:  
  - `min_rec` (1): B+Tree의 비리프 노드에서 최소값인 경우  
  - `deleted` (2): 삭제 표시된 레코드인 경우  
    (해당 레코드는 나중에 purge 작업에 의해 실제로 제거됩니다)

- **Nullable 필드 비트맵 (선택적)**:  
  NULL이 허용된 필드마다 1비트씩 사용하여  
  해당 필드가 NULL인지 여부를 나타냅니다.  
  비트 수는 바이트 단위로 반올림되며,  
  NULL인 필드는 실제 레코드 내에서 값이 생략됩니다.  
  만약 모든 필드가 NOT NULL이라면 이 비트맵은 존재하지 않습니다.

- **가변 길이 필드 길이 배열 (선택적)**:  
  가변 길이 필드를 위한 배열로, 각 필드의 데이터 길이를 저장합니다.  
  필드의 최대 길이에 따라 항목은 8비트 또는 16비트 정수로 구성됩니다.  
  가변 길이 필드가 없으면 이 배열은 포함되지 않습니다.

레코드 헤더는 한 레코드당 최소 5바이트이지만,  
가변 길이 필드가 많을수록 훨씬 커질 수 있습니다.



**클러스터 인덱스(Primary Key)**

클러스터 키(= PRIMARY KEY)는 InnoDB에서 가장 복잡한 구조의 레코드를 구성합니다.

![](../reference/innodb_diagrams/images/InnoDB_Structures/Record%20Clustered%20Leaf.png)

클러스터 인덱스의 리프 페이지에서 하나의 레코드는 다음과 같은 데이터를 포함합니다:

- **클러스터 키 필드**:  
  기본 키를 구성하는 필드들을 내부 저장 형식 그대로 연결하여  
  하나의 바이트 스트림으로 만듭니다.  
  각 필드 타입에 따라 정해진 방식으로 저장된 바이트가 단순히 이어붙여집니다.

- **트랜잭션 ID**:  
  해당 레코드를 마지막으로 수정한 트랜잭션의 48비트 ID입니다.

- **롤백 포인터 (Roll Pointer)**:  
  이 레코드를 마지막으로 수정한 트랜잭션의 undo 로그 위치를 가리키는 구조체입니다.  
  구성은 다음과 같습니다:  
  - 1비트: 삽입 여부를 나타내는 플래그  
  - 7비트: 롤백 세그먼트 ID  
  - 4바이트: undo 로그가 위치한 페이지 번호  
  - 2바이트: undo 로그 내의 오프셋

- **기본 키 외 나머지 필드**:  
  기본 키에 포함되지 않은 컬럼의 실제 데이터를 하나의 바이트 스트림으로 연결하여 저장합니다.


**비리프 페이지의 레코드 구조**

리프 노드가 아닌 페이지에서는 MVCC 기능을 사용하지 않기 때문에  
레코드 구조가 다음과 같이 단순해집니다:

![](../reference/innodb_diagrams/images/InnoDB_Structures/Record%20Clustered%20Non-Leaf.png)

- **트랜잭션 ID 및 롤백 포인터 없음**  
  (이전 트랜잭션 정보나 undo 로그가 필요하지 않기 때문)

- **기본 키 외 나머지 필드 대신, 자식 페이지 번호(child page number)**를 포함합니다.

- **기본 키 필드는 NULL이 될 수 없으므로, nullable 비트맵도 존재하지 않습니다.**


## 세컨더리 인덱스 (Secondary Indexes)

InnoDB에서 세컨더리 인덱스는 클러스터드 키(PRIMARY KEY)와 전체 구조는 동일합니다.  
단, **세컨더리 인덱스에는 비키(non-key) 필드가 아니라 클러스터드 키 필드**,  
즉 **PKV(Primary Key Value)**라고 불리는 필드들이 포함된다는 점에서 차이가 있습니다.

세컨더리 키와 클러스터드 키에 동일한 필드가 포함되어 있다면,  
**중복되는 필드는 세컨더리 인덱스 레코드에 저장되는 클러스터드 키(PKV)에서는 제거됩니다.**  
예를 들어, `PRIMARY KEY (a, b, c)`와 `KEY (a, d)`라는 세컨더리 인덱스가 있다면,  
세컨더리 인덱스는 (a, d)를 키로 가지고 있으며,  
PKV에는 중복되지 않은 (b, c)만 포함됩니다.

또한 **세컨더리 인덱스는 중복 가능하고 NULL 값을 포함할 수 있으므로**,  
필요한 경우 **nullable field bitmap**과 **variable field lengths array**가 존재할 수 있습니다.  
그 외의 경우에는 리프 페이지 구조는 매우 단순합니다.

![](../reference/innodb_diagrams/images/InnoDB_Structures/Record%20Secondary%20Leaf.png)

### 리프 페이지 구조

세컨더리 키 필드는 클러스터드 키와 마찬가지로 **단일 바이트 스트림으로 이어 붙여져 저장**되며,  
클러스터드 키 필드도 동일한 방식으로 PKV를 구성합니다.

![](../reference/innodb_diagrams/images/InnoDB_Structures/Record%20Secondary%20Non-Leaf.png)

### 비리프 페이지 구조

비리프 페이지 구조도 클러스터드 인덱스와 유사합니다.  
하지만 여기서 주목할 점은, **세컨더리 인덱스의 비리프 페이지 레코드에도 PKV가 포함된다는 것**입니다.  
이 PKV는 **레코드의 값(value)이 아닌, 키(key)의 일부로 간주**됩니다.

세컨더리 인덱스는 유니크하지 않아도 되지만,  
**페이지 내의 각 레코드는 고유한 식별자가 필요하므로**  
PKV를 함께 저장해야 유일성을 보장할 수 있습니다.

이로 인해 **세컨더리 인덱스의 비리프 페이지 레코드는 리프 페이지보다 4바이트 더 큽니다.**


## 레코드 단위 오버헤드에 대한 보충 설명

위에 나온 그림들을 보면, InnoDB가 레코드 하나를 저장할 때 발생하는 **오버헤드(overhead)** 를 쉽게 계산할 수 있습니다.

- **클러스터드 인덱스의 Leaf Page** 기준:
  - 레코드 헤더: 최소 5바이트
  - Transaction ID: 6바이트
  - Roll Pointer: 7바이트  
  → **합계 최소 18바이트의 오버헤드**

따라서 컬럼이 2~3개뿐인 **매우 좁은 테이블**에서는 이 오버헤드가 상대적으로 매우 큽니다.


## 페이지 단위 오버헤드

레코드 외에도 InnoDB 페이지는 다음과 같은 오버헤드가 존재합니다:

- 페이지 헤더, 페이지 디렉터리 등으로 인한 **고정적인 공간 소모**
- 페이지 내 레코드들이 **비효율적으로 채워질 경우 낭비 발생**  
  (예: 페이지가 절반만 채워지는 경우 등)

이러한 구조적 특성으로 인해 **디스크 공간이 상당히 낭비될 수 있습니다.**


## 다음 내용 예고

다음 글에서는 InnoDB가 레코드를 효율적으로 검색하기 위해 사용하는  
**페이지 디렉터리(page directory)** 구조와 그 역할을 다룰 예정입니다.


## 수정 사항

초기에 클러스터드 인덱스의 leaf 페이지에는  
nullable field bitmap이 존재하지 않는다고 잘못 서술했으나,  
사실 **비키 필드(non-key field)에 NULL이 있을 경우 해당 비트맵은 존재**합니다.  
단, **클러스터 키는 NULL이 될 수 없으므로**,  
**비리프 페이지에서는 항상 이 비트맵이 존재하지 않습니다.**
