# InnoDB 스페이스 파일의 페이지 관리
[원문 보기](https://blog.jcole.us/2013/01/04/page-management-in-innodb-space-files/)

---

"On learning InnoDB: A journey to the core" 글에서 InnoDB 내부 구조를 문서화하기 위한 `innodb_diagrams` 프로젝트를 소개했으며, 이 글에서 사용된 다이어그램들도 모두 해당 프로젝트에서 제작되었습니다. (아래 각 이미지는 더 고해상도 버전으로 링크되어 있습니다.)

"The basics of InnoDB space file layout" 글에서는 스페이스와 각 페이지의 기본 구조에 대해 설명했으며, 이제 이를 확장하여 InnoDB의 페이지 및 익스텐트 관리, "여유 공간" 관리와 관련된 구조들과, 페이지가 다양한 용도로 할당되는 방식을 추적하는 방법에 대해 설명하겠습니다.

## 익스텐트와 익스텐트 디스크립터

앞서 설명한 바와 같이, InnoDB 페이지는 보통 16 KiB 크기이며, 연속된 64개의 페이지가 1 MiB 블록으로 묶여 "익스텐트(extent)"라고 불립니다. InnoDB는 스페이스 내의 고정된 위치에 FSP_HDR 및 XDES 페이지를 할당하여 어떤 익스텐트가 사용 중인지, 각 익스텐트 내에서 어떤 페이지가 사용 중인지를 추적합니다. 이러한 페이지들은 상당히 단순한 구조를 가지고 있습니다:

![FSP_HDR Page Overview](../reference/innodb_diagrams/images/InnoDB_Structures/FSP_HDR%20Page%20Overview.png)

일반적인 FIL 헤더와 트레일러, FSP 헤더(나중에 설명), 그리고 256개의 "익스텐트 디스크립터(extent descriptor)" 또는 줄여서 "디스크립터"를 포함합니다. 또한 상당한 크기의 사용되지 않는 공간도 포함되어 있습니다.

익스텐트 디스크립터는 다음과 같은 구조를 가집니다:

![XDES Entry](../reference/innodb_diagrams/images/InnoDB_Structures/XDES%20Entry.png)

익스텐트 디스크립터의 다양한 필드들의 용도는 다음과 같습니다:

- **파일 세그먼트 ID**: 익스텐트가 파일 세그먼트에 속하는 경우, 해당 파일 세그먼트의 ID입니다.
- **XDES 리스트용 리스트 노드**: 이중 연결 익스텐트 디스크립터 리스트에서 이전 및 다음 익스텐트를 가리키는 포인터입니다.
- **상태**: 익스텐트의 현재 상태로, 현재 다음 네 가지 값만 정의되어 있습니다: FREE, FREE_FRAG, FULL_FRAG는 이 익스텐트가 동일한 이름의 스페이스 리스트에 속함을 의미하고, FSEG는 이 익스텐트가 파일 세그먼트 ID 필드에 저장된 ID를 가진 파일 세그먼트에 속함을 의미합니다. (이러한 리스트들에 대한 자세한 설명은 아래에서 다룹니다.)
- **페이지 상태 비트맵**: 익스텐트 내 페이지당 2비트씩 사용하는 비트맵(64 × 2 = 128비트, 즉 16바이트)입니다. 첫 번째 비트는 해당 페이지가 사용 가능한지를 나타냅니다. 두 번째 비트는 해당 페이지가 깨끗한지(플러시되지 않은 데이터가 없는지)를 나타내기 위해 예약되어 있지만, 현재는 사용되지 않으며 항상 1로 설정됩니다.

익스텐트를 참조하는 다른 구조들은 익스텐트의 디스크립터가 위치한 FSP_HDR 또는 XDES 페이지의 페이지 번호와 해당 페이지 내에서 디스크립터 엔트리 자체의 바이트 오프셋을 조합하여 사용합니다. 예를 들어, "페이지 0 오프셋 150"으로 참조되는 익스텐트는 스페이스의 첫 번째 익스텐트로 페이지 0-63을 담당하며, "페이지 16384 오프셋 270"은 페이지 16576-16639를 담당합니다.

## 리스트 베이스 노드와 리스트 노드

리스트(또는 InnoDB가 부르는 "프리 리스트")는 여러 관련 구조들을 연결할 수 있는 상당히 범용적인 구조입니다. 이는 잘 구성된 온디스크 이중 연결 리스트를 형성하는 두 개의 보완적인 구조로 구성됩니다. "리스트 베이스 노드"는 다음과 같은 구조를 가집니다:

![List Base Nodes](../reference/innodb_diagrams/images/InnoDB_Structures/List%20Base%20Nodes.png)

베이스 노드는 일부 상위 레벨 구조(예: FSP 헤더)에 단 한 번만 저장됩니다. 여기에는 리스트의 길이와 리스트의 첫 번째 및 마지막 리스트 노드에 대한 포인터가 포함됩니다. 실제 "리스트 노드"는 매우 유사하게 생겼습니다:

![List Nodes](../reference/innodb_diagrams/images/InnoDB_Structures/List%20Nodes.png)

물론 첫 번째와 마지막 포인터를 저장하는 대신, 리스트 노드는 이전 및 다음 포인터를 저장합니다.

모든 포인터는 페이지 번호(동일한 스페이스 내에 있어야 함)와 해당 페이지 내에서 리스트 노드를 찾을 수 있는 바이트 오프셋으로 구성됩니다. 모든 포인터는 리스트 노드의 시작 부분(즉, N+0)을 가리키며, 반드시 연결되는 _구조체_의 시작 부분을 가리키지는 않습니다. 예를 들어, 익스텐트 디스크립터 엔트리가 리스트에 연결될 때, 리스트 노드가 XDES 엔트리 구조 내에서 오프셋 8에 위치하므로, 리스트 엔트리를 읽는 코드는 디스크립터 구조가 리스트 노드 오프셋보다 8바이트 _앞에서_ 시작한다는 것을 "알고" 있어야 하며, 그 지점부터 구조체를 읽어야 합니다. (리스트 노드가 항상 어떤 구조체의 첫 번째 요소가 되도록 하는 것이 좋은 아이디어였겠지만, 실제로는 그렇지 않습니다.)

## 파일 스페이스 헤더와 익스텐트 리스트

익스텐트 디스크립터 엔트리 자체를 저장하는 것 외에도, FSP_HDR 페이지(스페이스의 항상 페이지 0)는 많은 리스트를 포함하는 FSP 헤더도 저장하므로, 앞서 쉽게 설명하기 어려웠습니다. FSP 헤더의 구조는 다음과 같습니다:

![FSP Header](../reference/innodb_diagrams/images/InnoDB_Structures/FSP%20Header.png)

FSP 헤더의 리스트 관련이 아닌 필드들의 용도는 다음과 같습니다 (순서 무관):

- **스페이스 ID**: 현재 스페이스의 스페이스 ID입니다.
- **스페이스 내 최고 페이지 번호(크기)**: "크기"는 최고 유효 페이지 번호이며, 파일이 확장될 때 증가합니다. 하지만 이 모든 페이지가 초기화된 것은 아닙니다(일부는 0으로 채워져 있을 수 있음). 스페이스 확장은 다단계 프로세스이기 때문입니다.
- **초기화된 최고 페이지 번호(free limit)**: "free limit"은 FIL 헤더가 초기화된 최고 페이지 번호로, 페이지 자체에 페이지 번호를 저장하는 등의 작업이 완료된 것을 의미합니다. free limit은 항상 크기보다 작거나 같습니다.
- **플래그**: 스페이스와 관련된 플래그를 저장합니다.
- **다음 사용되지 않은 세그먼트 ID**: 다음에 할당될 파일 세그먼트에 사용될 파일 세그먼트 ID입니다. (본질적으로 자동 증가 정수입니다.)
- **FREE_FRAG 리스트에서 사용된 페이지 수**: FREE_FRAG 리스트의 여유 페이지 수를 빠르게 계산하기 위한 최적화로 저장되며, 리스트의 모든 익스텐트를 반복하며 각각의 여유 페이지를 합산하지 않고도 계산할 수 있습니다.

다음 익스텐트 디스크립터 리스트들에 대한 리스트 베이스 노드들도 FSP 헤더에 저장됩니다:

- **FREE_FRAG**: 여유 페이지가 남아있는 익스텐트들로, "조각(fragment)"으로 사용되기 위해 할당된 것들입니다. 즉, 전체 익스텐트를 할당하지 않고 개별 페이지를 다른 용도로 할당하는 것입니다. 예를 들어, FSP_HDR 또는 XDES 페이지가 있는 모든 익스텐트는 FREE_FRAG 리스트에 배치되어 익스텐트 내 나머지 여유 페이지들을 다른 용도로 할당할 수 있습니다.
- **FULL_FRAG**: FREE_FRAG와 정확히 동일하지만 여유 페이지가 남아있지 않은 익스텐트들입니다. 익스텐트가 가득 차면 FREE_FRAG에서 FULL_FRAG로 이동하고, 페이지가 해제되어 더 이상 가득 차지 않으면 다시 FREE_FRAG로 이동합니다.
- **FREE**: 완전히 사용되지 않고 어떤 용도로든 전체적으로 할당할 수 있는 익스텐트들입니다. FREE 익스텐트는 파일 세그먼트에 할당되어 (적절한 INODE 리스트에 배치) 사용되거나, 개별 페이지 사용을 위해 FREE_FRAG 리스트로 이동할 수 있습니다.

## 파일 세그먼트와 아이노드

파일 세그먼트와 아이노드는 아마도 InnoDB의 용어와 문서화가 가장 모호한 부분일 것입니다. InnoDB는 파일시스템에서 흔히 사용되는 "inode"라는 용어를 오버로딩하여 INODE _엔트리_(하나의 작은 구조체)와 INODE _페이지_(많은 INODE 엔트리를 담는 페이지 타입) 모두에 사용합니다. 잠시 명명 혼란을 무시하고, InnoDB의 INODE 엔트리는 단순히 파일 세그먼트(자주 FSEG라고 불림)를 설명하며, 앞으로는 "파일 세그먼트 INODE"라고 부르겠습니다. 이를 포함하는 INODE 페이지는 다음과 같은 구조를 가집니다:

![INODE Page Overview](../reference/innodb_diagrams/images/InnoDB_Structures/INODE%20Page%20Overview.png)

각 INODE 페이지는 85개의 파일 세그먼트 INODE 엔트리(16 KiB 페이지 기준)를 포함하며, 각각은 192바이트입니다. 또한, 위에서 설명한 FSP_HDR의 FSP 헤더 구조에 있는 다음 INODE 페이지 리스트에서 사용되는 리스트 노드도 포함합니다:

- **FREE_INODES**: 최소 하나의 여유 파일 세그먼트 INODE 엔트리가 있는 INODE 페이지들의 리스트입니다.
- **FULL_INODES**: 여유 파일 세그먼트 INODE 엔트리가 전혀 없는 INODE 페이지들의 리스트입니다. "file per table" 스페이스를 사용할 때, 테이블이 42개 이상의 인덱스를 가지지 않는 한 각 테이블별 스페이스의 이 리스트는 비어있을 것입니다. 각 인덱스는 정확히 두 개의 파일 세그먼트 INODE 엔트리를 소모하기 때문입니다.

파일 세그먼트 INODE 엔트리는 다음과 같은 구조를 가집니다:

![INODE Entry](../reference/innodb_diagrams/images/InnoDB_Structures/INODE%20Entry.png)

각 INODE 엔트리의 리스트가 아닌 필드들의 용도는 다음과 같습니다:

- **세그먼트 ID**: 파일 세그먼트 ID입니다.
- **사용되지 않은 페이지 수**: 할당되었지만 사용되지 않은 페이지 수입니다. 이는 일반적으로 각 익스텐트에 대한 익스텐트 디스크립터의 페이지 상태 비트맵에서 계산할 수 있지만, 성능상의 이유로 여기에 캐시됩니다.
- **조각 배열**: 파일 세그먼트에 할당된 개별 페이지들의 32개 슬롯 배열입니다. 이는 파일 세그먼트가 전체 익스텐트를 할당하기 전에 개별 페이지들을 할당받을 수 있게 해줍니다.

테이블이 성장하면서 조각 배열이 가득 찰 때까지 각 파일 세그먼트에서 개별 페이지를 할당하다가, 한 번에 1개 익스텐트씩 할당하는 방식으로 전환하고, 최종적으로는 한 번에 4개 익스텐트씩 할당하는 방식으로 전환합니다.

익스텐트 디스크립터의 리스트 베이스 노드들도 각 파일 세그먼트 INODE 엔트리에 존재합니다:

- **FREE**: 완전히 사용되지 않으며 이 파일 세그먼트에 할당된 익스텐트들입니다.
- **NOT_FULL**: 이 파일 세그먼트에 할당된 익스텐트들 중 최소 하나의 사용된 페이지가 있는 것들입니다. 마지막 여유 페이지가 사용되면 익스텐트는 FULL 리스트로 이동합니다.
- **FULL**: 이 파일 세그먼트에 할당된 익스텐트들 중 여유 페이지가 없는 것들입니다. 페이지가 여유로워지면 익스텐트는 NOT_FULL 리스트로 이동합니다.

NOT_FULL 리스트의 익스텐트에서 마지막 사용된 페이지가 해제되면 파일 세그먼트의 FREE 리스트로 이동할 수 있지만, 실제로는 대신 스페이스의 FREE 리스트로 직접 이동합니다.

## 인덱스가 파일 세그먼트를 사용하는 방법

INDEX 페이지들은 아직 설명하지 않았지만, 하나의 작은 측면은 지금 살펴볼 수 있습니다. 각 인덱스의 루트 페이지에 있는 FSEG 헤더는 인덱스가 사용하는 파일 세그먼트를 설명하는 파일 세그먼트 INODE 엔트리들에 대한 포인터를 포함합니다. 각 인덱스는 리프 페이지용 파일 세그먼트 하나와 비리프(내부) 페이지용 파일 세그먼트 하나를 사용합니다. 이 정보는 FSEG 헤더 구조(INDEX 페이지 내)에 저장됩니다:

![Index File Segment Structure](../reference/innodb_diagrams/images/InnoDB_Structures/Index%20File%20Segment%20Structure.png)

존재하는 스페이스 ID들은 다소 불필요합니다 — 항상 현재 스페이스와 동일할 것입니다. 페이지 번호와 오프셋은 INODE 페이지의 파일 세그먼트 INODE 엔트리를 가리킵니다. 비어있을 수 있지만 두 파일 세그먼트 모두 항상 존재합니다.

예를 들어, 새로 생성된 테이블에서는 루트 페이지만 존재하며, 이는 리프 페이지이기도 하지만 "내부" 파일 세그먼트에 있습니다 (나중에 이동할 필요가 없도록). "리프" 파일 세그먼트 INODE 리스트와 조각 배열은 모두 비어있을 것입니다. "내부" 파일 세그먼트 INODE 리스트들은 모두 비어있을 것이고, 단일 루트 페이지는 조각 배열에 있을 것입니다.

## 모든 것을 연결하기

다음 다이어그램은 인덱스에 대한 전체 다단계 구조를 설명하려고 시도합니다:

![High-level Overview](../reference/innodb_diagrams/images/InnoDB_Structures/High-level%20Overview.png)

인덱스 루트 페이지는 두 개의 아이노드(파일 세그먼트)를 가리키며, 각각은 조각 배열(조각 리스트의 최대 32개 개별 페이지를 가리킴)과 여러 전체 익스텐트 리스트를 가지고 있습니다. 이들은 익스텐트 디스크립터의 리스트 포인터를 사용하여 연결됩니다. 익스텐트 디스크립터는 익스텐트를 참조하는 동시에 익스텐트 내의 여유 페이지를 추적하는 데 사용됩니다. 간단하죠!

## 다음에는?

다음에는 사용자 관점에서 가장 중요한 페이지 타입 중 하나인 INDEX 페이지의 구조를 살펴볼 것입니다. 그 다음 InnoDB가 인덱스를 높은 수준에서 어떻게 구성하는지 알아보겠습니다. 