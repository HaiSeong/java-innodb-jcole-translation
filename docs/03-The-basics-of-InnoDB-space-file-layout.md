# InnoDB 스페이스 파일 구조의 기본 개념  
[원문 보기](https://blog.jcole.us/2013/01/02/on-learning-innodb-a-journey-to-the-core/)

---

"On learning InnoDB: A journey to the core" 글에서  
InnoDB의 내부 구조를 정리하고 시각화하기 위해 시작한 `innodb_diagrams` 프로젝트를 소개한 바 있습니다.  
이번 글에 사용된 도표들도 모두 그 프로젝트를 통해 제작된 것입니다.


InnoDB의 데이터 저장 모델은 "space"라는 개념을 사용합니다.  
MySQL에서는 일반적으로 "테이블스페이스(tablespace)"라고 부르며,  
InnoDB 내부에서는 "파일 스페이스(file space)"라는 표현을 쓰기도 합니다.

하나의 space는 운영체제 상에서 여러 개의 실제 파일(예: ibdata1, ibdata2 등)로 구성될 수 있지만,  
InnoDB는 이를 단일한 논리적 파일로 취급합니다.  
즉, 여러 물리적 파일이 하나의 파일처럼 연결되어 있는 것처럼 동작합니다.


InnoDB의 각 스페이스(space)에는 고유한 32비트 정수형 ID가 부여되며,  
이 ID는 다양한 위치에서 해당 스페이스를 식별하는 데 사용됩니다.

InnoDB에는 항상 존재하는 "시스템 스페이스(system space)"가 있으며,  
이 스페이스는 항상 ID 0번으로 지정됩니다.  
시스템 스페이스는 InnoDB 내부의 다양한 특수 기록 작업(bookkeeping)에 사용됩니다.

현재 MySQL에서는 InnoDB가 "file-per-table" 방식의 추가적인 스페이스만을 지원합니다.  
이 방식은 MySQL의 각 테이블마다 별도의 `.ibd` 파일을 생성하는 구조입니다.

이 `.ibd` 파일은 InnoDB 내부적으로는 여러 테이블을 담을 수 있는 독립적인 스페이스로 동작하지만,  
MySQL과 함께 사용할 경우 실제로는 하나의 테이블만 저장하는 용도로 사용됩니다.



## 페이지 (Pages)

InnoDB의 각 스페이스는 여러 개의 페이지로 구성되어 있으며,  
기본적으로 각 페이지의 크기는 16 KiB입니다.  
다만 컴파일 시 `UNIV_PAGE_SIZE` 값을 변경했거나, InnoDB 압축 기능을 사용할 경우 페이지 크기는 달라질 수 있습니다.

스페이스 내의 각 페이지는 고유한 32비트 정수형 번호를 가지며,  
이는 종종 "오프셋(offset)"이라고 불립니다.  
이 오프셋은 해당 페이지가 스페이스의 시작점으로부터 얼마나 떨어져 있는지를 의미합니다  
(스페이스가 여러 파일로 나뉘는 경우, 꼭 파일 기준은 아닙니다).

예를 들어, 페이지 0은 파일 오프셋 0에,  
페이지 1은 파일 오프셋 16,384(= 16 KiB)에 위치하며, 이런 식으로 순차적으로 배치됩니다.

혹시 기억하실 수도 있지만, InnoDB는 64TiB의 최대 용량 제한이 있습니다.  
이는 스페이스 단위로 적용되며, 32비트 페이지 번호와 기본 페이지 크기(16 KiB)로 인해  
2³² × 16 KiB = 64 TiB라는 계산에서 비롯된 제한입니다.


각 페이지는 다음과 같은 형식으로 구성됩니다:

![Basic Page Overview](../reference/innodb_diagrams/images/InnoDB_Structures/Basic%20Page%20Overview.png)

모든 페이지는 38바이트 길이의 FIL 헤더와 8바이트의 FIL 트레일러를 포함하고 있습니다.  
여기서 FIL은 "file"의 줄임말입니다.

헤더에는 해당 페이지의 타입을 나타내는 필드가 포함되어 있으며,  
이 타입에 따라 이후 페이지의 전체 구조가 결정됩니다.

FIL 헤더와 트레일러는 다음과 같은 형식으로 구성되어 있습니다:

![](../reference/innodb_diagrams/images/InnoDB_Structures/FIL%20Header%20and%20Trailer.png)

FIL 헤더와 트레일러에는 다음과 같은 정보들이 포함되어 있습니다 (순서는 무관합니다):

- **페이지 타입**: 페이지의 타입은 헤더에 저장되며,  
  이를 통해 나머지 페이지의 내용을 어떤 구조로 해석해야 할지를 판단할 수 있습니다.  
  InnoDB는 파일 공간 관리, 익스텐트(extent) 관리, 트랜잭션 시스템, 데이터 딕셔너리,  
  Undo 로그, BLOB, 그리고 인덱스(즉, 테이블 데이터) 저장을 위해 다양한 페이지를 사용합니다.

- **스페이스 ID**: 페이지가 속한 스페이스 ID가 헤더에 저장됩니다.

- **페이지 번호**: 페이지가 초기화된 이후에는 해당 페이지의 번호가 헤더에 기록됩니다.  
  이 필드의 값이 실제 파일 오프셋 기준으로 예상되는 페이지 번호와 일치하는지 확인하면,  
  페이지가 정상적으로 읽혔는지 판단하는 데 도움이 됩니다.  
  이 필드가 채워져 있다는 것은 해당 페이지가 초기화되었음을 의미합니다.

- **체크섬**: 헤더에는 32비트 체크섬이 저장되며,  
  트레일러에는 예전 형식의(현재는 잘못된 것으로 간주되는) 32비트 체크섬이 저장됩니다.  
  이 오래된 체크섬 필드는 향후 폐기되어 공간이 재활용될 수 있습니다.

- **앞/뒤 페이지 포인터**: 같은 타입의 이전 페이지와 다음 페이지를 가리키는 포인터가 헤더에 저장됩니다.  
  이를 통해 이중 연결 리스트(doubly-linked list)가 구성되며,  
  특히 인덱스 페이지에서는 같은 레벨의 페이지들을 연결하여 전체 인덱스 스캔 시 효율을 높입니다.  
  단, 모든 페이지 타입이 이 필드를 사용하는 것은 아닙니다.

- **LSN (Log Sequence Number)**: 해당 페이지가 마지막으로 수정되었을 때의 64비트 LSN이 헤더에 저장되며,  
  이 LSN의 하위 32비트는 트레일러에 함께 기록됩니다.

- **Flush LSN**: 헤더에는 64비트 크기의 "Flush LSN" 필드도 포함되어 있으며,  
  이는 시스템 전체에서 단 하나, space 0의 페이지 0에만 실제 값이 채워집니다.  
  이 필드는 전체 시스템(모든 스페이스 포함)에서 디스크에 기록된 가장 최근의 LSN 값을 나타냅니다.  
  현재는 한 페이지만 사용하지만, 다른 용도로 재활용할 수 있는 여지도 있는 필드입니다.



## 스페이스 파일 (Space Files)

스페이스 파일은 최대 2³²개의 페이지를 단순히 이어 붙인 형태로 구성됩니다.  
효율적인 관리를 위해, InnoDB는 페이지들을 1MiB 단위의 블록으로 묶어 관리하는데,  
기본 페이지 크기인 16KiB 기준으로 연속된 64개의 페이지가 하나의 **익스텐트(extent)**를 구성합니다.  
이후 대부분의 구조는 페이지를 직접 다루지 않고, 익스텐트를 기준으로 페이지를 할당하거나 참조합니다.

InnoDB는 각 페이지와 익스텐트, 그리고 전체 스페이스 자체를 관리하기 위해  
일정한 기록 관리(bookkeeping)를 수행해야 하며,  
이 때문에 스페이스 파일에는 필수적으로 상위 관리 구조(super-structure)가 포함됩니다:

![](../reference/innodb_diagrams/images/InnoDB_Structures/Space%20File%20Overview.png)

스페이스의 첫 번째 페이지(페이지 0)는 항상 FSP_HDR, 즉 "파일 스페이스 헤더(file space header)" 페이지입니다.  
이 페이지에는 FSP 헤더 구조체가 포함되어 있으며,  
스페이스 전체의 크기, 사용 가능한 익스텐트 목록, 조각난(extent) 목록,  
그리고 가득 찬(extent) 목록 등을 관리합니다.  
(여유 공간 관리에 대한 더 자세한 설명은 이후 글에서 다룰 예정입니다.)

FSP_HDR 페이지는 내부적으로 최대 256개의 익스텐트(= 16,384 페이지, 약 256MiB)에 대한  
관리 정보를 저장할 수 있습니다.  
따라서 16,384 페이지마다 추가적인 관리 정보 저장을 위해  
XDES 페이지가 자동으로 할당됩니다.  
XDES 페이지는 FSP_HDR 페이지와 구조는 동일하지만,  
FSP 헤더 부분은 0으로 채워져 있습니다.

또한 각 스페이스의 세 번째 페이지(페이지 2)는 **INODE 페이지**로 사용되며,  
이는 파일 세그먼트(file segment: 익스텐트 그룹 + 단일 페이지 배열)를 관리하는 데 사용됩니다.  
INODE 페이지 하나당 최대 85개의 INODE 엔트리를 저장할 수 있고,  
하나의 인덱스는 두 개의 INODE 엔트리를 필요로 합니다.  
(INODE 엔트리와 파일 세그먼트에 대한 자세한 설명은 추후 별도로 다룰 예정입니다.)

또한 각 FSP_HDR 또는 XDES 페이지에는  
insert buffering 관련 관리 정보를 담는 **IBUF_BITMAP 페이지**도 함께 존재합니다.  
이 페이지는 이 글의 범위에서는 다루지 않습니다.



## 시스템 스페이스 (System Space)

InnoDB에서 시스템 스페이스(스페이스 0번)는 특별한 공간으로,  
InnoDB의 동작에 필수적인 다양한 정보를 저장하기 위해  
특정한 페이지 번호에 고정적으로 여러 페이지가 할당되어 있습니다.

시스템 스페이스도 일반적인 스페이스와 마찬가지로  
가장 처음 세 페이지에는 FSP_HDR, IBUF_BITMAP, INODE 페이지가 순서대로 배치되어 있습니다.  
하지만 그 이후부터는 일반 스페이스와 다른 특수한 구성을 가집니다.

![](../reference/innodb_diagrams/images/InnoDB_Structures/ibdata1%20File%20Overview.png)

다음과 같은 페이지들이 예약되어 있습니다:

- **페이지 3 (타입: SYS)**: insert buffering과 관련된 헤더 및 관리 정보
- **페이지 4 (타입: INDEX)**: insert buffering에 사용되는 인덱스 구조의 루트 페이지
- **페이지 5 (타입: TRX_SYS)**: InnoDB 트랜잭션 시스템의 주요 정보를 저장  
  예를 들어, 가장 최신의 트랜잭션 ID, MySQL의 바이너리 로그 정보,  
  double write buffer 익스텐트의 위치 등이 여기에 포함됩니다.
- **페이지 6 (타입: SYS)**: 첫 번째 롤백 세그먼트 페이지  
  필요에 따라 추가적인 페이지 또는 익스텐트가 롤백 세그먼트 데이터를 위해 할당됩니다.
- **페이지 7 (타입: SYS)**: 데이터 딕셔너리 관련 헤더 페이지  
  데이터 딕셔너리를 구성하는 인덱스들의 루트 페이지 번호가 저장되며,  
  이는 다른 인덱스(테이블)의 위치를 찾는 데 필수적인 정보입니다.  
  각 인덱스의 루트 페이지 번호는 모두 데이터 딕셔너리에 기록됩니다.
- **페이지 64–127**: double write buffer의 첫 번째 블록 (64페이지 = 1 extent)  
  double write buffer는 InnoDB의 장애 복구 과정에서 사용됩니다.
- **페이지 128–191**: double write buffer의 두 번째 블록

그 외의 모든 페이지들은 필요에 따라 인덱스, 롤백 세그먼트, undo 로그 등에 동적으로 할당됩니다.



## 테이블별 스페이스 파일 (Per-table Space Files)

InnoDB는 "file-per-table" 모드를 제공하며,  
이 모드에서는 MySQL 테이블 하나가 생성될 때마다 하나의 파일이 함께 생성됩니다.  
(사실 이 파일은 앞서 설명했듯 물리적으로는 파일이지만 논리적으로는 하나의 스페이스입니다.)  
이 기능의 이름은 "파일 per 테이블"보다는 "스페이스 per 테이블"이라고 부르는 것이 더 적절할 수 있습니다.  
생성된 `.ibd` 파일은 일반적인 스페이스 파일 구조를 그대로 따릅니다.

![](../reference/innodb_diagrams/images/InnoDB_Structures/IBD%20File%20Overview.png)

런타임 중 인덱스를 추가하는 "fast index creation" 기능을 제외하면,  
필수적인 첫 3개의 페이지가 생성된 후  
그 다음 페이지들에는 테이블 내 각 인덱스의 루트 페이지가 순서대로 배치됩니다.  
이 순서는 테이블 생성 시 정의한 순서를 따릅니다.  
예를 들어, 페이지 3은 클러스터드 인덱스의 루트,  
페이지 4는 첫 번째 보조 인덱스의 루트가 됩니다.

InnoDB의 대부분의 관리용 구조(bookkeeping)는 시스템 스페이스에 저장되므로,  
테이블별 스페이스에 생성되는 페이지는 대부분 INDEX 타입이며,  
실제 테이블 데이터를 저장하는 용도로 사용됩니다.

## 다음 글

다음 글에서는 InnoDB 내부의 여유 공간 관리 방식에 대해 다룰 예정입니다.  
구체적으로는 익스텐트 디스크립터(extent descriptor),  
파일 세그먼트(INODE), 그리고 리스트 구조에 대해 살펴보겠습니다.
